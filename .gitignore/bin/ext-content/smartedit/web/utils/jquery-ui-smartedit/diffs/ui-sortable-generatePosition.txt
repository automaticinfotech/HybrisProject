_generatePosition: function(event) {

    var top, left,
        o = this.options,
        pageX = event.pageX,
        pageY = event.pageY,
        scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

    // This is another very weird special case that only happens for relative elements:
    // 1. If the css position is relative
    // 2. and the scroll parent is the document or similar to the offset parent
    // we have to refresh the relative offset during the scroll so there are no jumps
    if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
        this.offset.relative = this._getRelativeOffset();
    }

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    if(this.originalPosition) { //If we are not dragging yet, we won't check for options

        if(this.containment) {
            if(event.pageX - this.offset.click.left < this.containment[0]) {
                pageX = this.containment[0] + this.offset.click.left;
            }
            if(event.pageY - this.offset.click.top < this.containment[1]) {
                pageY = this.containment[1] + this.offset.click.top;
            }
            if(event.pageX - this.offset.click.left > this.containment[2]) {
                pageX = this.containment[2] + this.offset.click.left;
            }
            if(event.pageY - this.offset.click.top > this.containment[3]) {
                pageY = this.containment[3] + this.offset.click.top;
            }
        }

        if(o.grid) {
            top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
            pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
            pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
        }

    }

    // SmartEdit Fix
    if($.ui.smartedit._isDragging()){

        // Draggable
        return {
            top: (
                pageY -
                this.offset.click.top +
                - $.ui.smartedit._getToolbarHeight()
                + $.ui.smartedit._getIframeScrollTop()
            ),
            left: (
                pageX -																// The absolute mouse position
                this.offset.click.left -												// Click offset (relative to the element)
                this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
            )
        };


    } else {

        // Sortable
        // jQuery Core

        return {
            top: (
                pageY -																// The absolute mouse position
                this.offset.click.top -													// Click offset (relative to the element)
                this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
            ),
            left: (
                pageX -																// The absolute mouse position
                this.offset.click.left -												// Click offset (relative to the element)
                this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
            )
        };

    }

},